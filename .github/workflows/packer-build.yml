name: Build Custom AMI with Packer

# Trigger: Only runs when PR is merged to main (push event)
# Paths: Only runs if relevant files changed
on:
  push:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'packer/**'
      - 'pom.xml'
      - '.github/workflows/packer-build.yml'

env:
  PACKER_LOG: 1  # Enable Packer debug logging for troubleshooting

permissions:
  contents: read  # Read-only access to repository contents

# Prevent multiple AMI builds from running simultaneously
concurrency:
  group: packer-build-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Job 1: Run integration tests with MySQL
  # Fails entire workflow if tests fail (no AMI built)
  integration-test:
    name: Run Integration Tests
    runs-on: ubuntu-latest

    # MySQL service container for integration tests
    services:
      mysql:
        image: mysql:8.0
        env:
          # Use secrets for passwords, variables for non-sensitive config
          MYSQL_ROOT_PASSWORD: ${{ secrets.TEST_MYSQL_ROOT_PASSWORD }}
          MYSQL_DATABASE: ${{ vars.TEST_MYSQL_DATABASE }}
          MYSQL_USER: ${{ vars.TEST_MYSQL_USER }}
          MYSQL_PASSWORD: ${{ secrets.TEST_MYSQL_PASSWORD }}
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping -h 127.0.0.1 -uroot -p${{ secrets.TEST_MYSQL_ROOT_PASSWORD }} --silent"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'  # Cache Maven dependencies for faster builds

      # Ubuntu runners don't include mysqladmin by default
      - name: Install MySQL client
        run: sudo apt-get update -y && sudo apt-get install -y mysql-client

      # Wait up to 2 minutes for MySQL to be ready
      - name: Wait for MySQL to be ready
        run: |
          for i in {1..60}; do
            if mysqladmin ping -h 127.0.0.1 -u${{ vars.TEST_MYSQL_USER }} -p${{ secrets.TEST_MYSQL_PASSWORD }} --silent; then
              echo " MySQL is ready!"
              exit 0
            fi
            echo "Waiting for MySQL... ($i/60)"
            sleep 2
          done
          echo " MySQL did not become ready in time"
          exit 1

      # Run all integration tests - MUST pass before building AMI
      - name: Run integration tests
        env:
          SPRING_DATASOURCE_URL: jdbc:mysql://localhost:3306/${{ vars.TEST_MYSQL_DATABASE }}?serverTimezone=UTC&useSSL=false&allowPublicKeyRetrieval=true
          SPRING_DATASOURCE_USERNAME: ${{ vars.TEST_MYSQL_USER }}
          SPRING_DATASOURCE_PASSWORD: ${{ secrets.TEST_MYSQL_PASSWORD }}
        run: |
          echo "Running integration tests..."
          ./mvnw -B clean verify

  # Job 2: Build application JAR artifact
  # Only runs if integration tests pass
  build-artifact:
    name: Build Application Artifact
    runs-on: ubuntu-latest
    needs: integration-test  # Dependency: waits for tests to pass

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      # Build JAR on GitHub runner (NOT in Packer template)
      # Skip tests since we already ran them in previous job
      - name: Build JAR artifact
        run: |
          echo "Building application artifact..."
          ./mvnw -B clean package -DskipTests
          
          # Find the JAR, excluding source/javadoc JARs
          JAR_FILE=$(find target -type f -name "*.jar" ! -name "*sources.jar" ! -name "*javadoc.jar" | head -1)
          
          if [ -z "$JAR_FILE" ]; then
            echo " No JAR file found in target/"
            exit 1
          fi
          
          # Export JAR path for next steps
          echo "JAR_PATH=$JAR_FILE" >> $GITHUB_ENV
          echo " Built JAR: $JAR_FILE"
          ls -lh "$JAR_FILE"

      # Upload JAR as artifact to pass between jobs
      # Retention: 1 day (only needed for this workflow run)
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: application-jar
          path: ${{ env.JAR_PATH }}
          if-no-files-found: error
          retention-days: 1

  # Job 3: Build custom AMI with Packer
  # Only runs if JAR build succeeds
  build-ami:
    name: Build Custom AMI
    runs-on: ubuntu-latest
    needs: build-artifact  # Dependency: waits for JAR to be built

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Download JAR artifact from previous job
      - name: Download application artifact
        uses: actions/download-artifact@v4
        with:
          name: application-jar
          path: target/

      - name: Verify artifact downloaded
        run: |
          echo "Contents of target/ after download:"
          ls -lh target/
          
          JAR_FILE=$(find target -type f -name "*.jar" ! -name "*sources.jar" ! -name "*javadoc.jar" | head -1)
          
          if [ -z "$JAR_FILE" ]; then
            echo " JAR file not found after download"
            exit 1
          fi
          
          # Export for use in Packer commands
          echo "JAR_PATH=$JAR_FILE" >> $GITHUB_ENV
          echo " Using JAR: $JAR_FILE"

      # Install jq for parsing manifest.json
      - name: Install required tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      # Configure AWS credentials for DEV account
      # Uses secrets for sensitive credentials
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      # Verify we're authenticated to the correct AWS account
      - name: Verify AWS identity
        run: |
          echo "Verifying AWS credentials..."
          aws sts get-caller-identity

      - name: Setup Packer
        uses: hashicorp/setup-packer@v2
        with:
          version: 'latest'

      # Initialize Packer plugins
      - name: Packer init
        working-directory: packer
        run: |
          echo "Initializing Packer..."
          packer init .

      # CRITICAL: Fail if files are not formatted
      # Cannot auto-fix from CI, so must fail the build
      - name: Packer format check
        working-directory: packer
        run: |
          echo "Checking Packer formatting..."
          packer fmt -check -recursive .
          echo " Packer files are properly formatted"

      # Validate Packer template syntax before building
      # Uses PKR_VAR_* environment variables instead of -var flags
      - name: Packer validate
        working-directory: packer
        env:
          # Non-sensitive config from Variables
          PKR_VAR_aws_region: ${{ vars.AWS_REGION }}
          PKR_VAR_subnet_id: ${{ vars.SUBNET_ID }}
          PKR_VAR_security_group_id: ${{ vars.SECURITY_GROUP_ID }}
          PKR_VAR_mysql_database: ${{ vars.MYSQL_DATABASE }}
          PKR_VAR_mysql_user: ${{ vars.MYSQL_USER }}
          # Sensitive data from Secrets
          PKR_VAR_ami_users: '["${{ secrets.DEMO_ACCOUNT_ID }}"]'
          PKR_VAR_mysql_password: ${{ secrets.MYSQL_PASSWORD }}
        run: |
          echo "Validating Packer template..."
          packer validate \
            -var "app_artifact_path=../${{ env.JAR_PATH }}" \
            .
          echo " Packer template is valid"

      # Build the custom AMI (5-10 minutes)
      # Creates Ubuntu 24.04 image with app pre-installed
      - name: Build AMI with Packer
        working-directory: packer
        env:
          PKR_VAR_aws_region: ${{ vars.AWS_REGION }}
          PKR_VAR_subnet_id: ${{ vars.SUBNET_ID }}
          PKR_VAR_security_group_id: ${{ vars.SECURITY_GROUP_ID }}
          PKR_VAR_ami_users: '["${{ secrets.DEMO_ACCOUNT_ID }}"]'
          PKR_VAR_mysql_database: ${{ vars.MYSQL_DATABASE }}
          PKR_VAR_mysql_user: ${{ vars.MYSQL_USER }}
          PKR_VAR_mysql_password: ${{ secrets.MYSQL_PASSWORD }}
        run: |
          echo "Building custom AMI..."
          echo "Region: ${{ vars.AWS_REGION }}"
          echo "Subnet: ${{ vars.SUBNET_ID }}"
          echo "Security Group: ${{ vars.SECURITY_GROUP_ID }}"
          echo "This will take 5-10 minutes..."
          packer build \
            -var "app_artifact_path=../${{ env.JAR_PATH }}" \
            .

      # Parse AMI ID from Packer's manifest.json output
      - name: Extract AMI ID from manifest
        working-directory: packer
        run: |
          if [ ! -f manifest.json ]; then
            echo " manifest.json not found"
            exit 1
          fi
          
          # Extract AMI ID from JSON (format: us-east-1:ami-xxxxx)
          AMI_ID=$(jq -r '.builds[-1].artifact_id' manifest.json | awk -F: '{print $2}')
          
          if [ -z "$AMI_ID" ] || [ "$AMI_ID" = "null" ]; then
            echo " Could not parse AMI ID from manifest"
            cat manifest.json
            exit 1
          fi
          
          echo "AMI_ID=$AMI_ID" >> $GITHUB_ENV
          echo " Created AMI: $AMI_ID"

      # Verify AMI exists and is in available state
      - name: Verify AMI state
        run: |
          echo "Verifying AMI was created successfully..."
          aws ec2 describe-images \
            --image-ids "${{ env.AMI_ID }}" \
            --region "${{ vars.AWS_REGION }}" \
            --query 'Images[0].[ImageId,Name,State,CreationDate]' \
            --output table

      # CRITICAL: Verify AMI is shared with DEMO account
      # This is a requirement - fail if sharing didn't work
      - name: Verify AMI is shared with DEMO account
        run: |
          echo "Verifying AMI is shared with DEMO account..."
          SHARED=$(aws ec2 describe-image-attribute \
            --image-id "${{ env.AMI_ID }}" \
            --attribute launchPermission \
            --region "${{ vars.AWS_REGION }}" \
            --query "LaunchPermissions[?UserId=='${{ secrets.DEMO_ACCOUNT_ID }}'].UserId" \
            --output text)
          
          if [ "$SHARED" = "${{ secrets.DEMO_ACCOUNT_ID }}" ]; then
            echo " AMI is shared with DEMO account: ${{ secrets.DEMO_ACCOUNT_ID }}"
          else
            echo " AMI is NOT shared with DEMO account"
            exit 1
          fi

      # Create GitHub Actions job summary with AMI details
      # Visible in the Actions UI for easy reference
      - name: Create job summary
        if: always()  # Run even if previous steps failed
        run: |
          {
            echo "##  AMI Build Summary"
            echo ""
            echo "| Property | Value |"
            echo "|----------|-------|"
            echo "| **Status** | ${{ job.status }} |"
            echo "| **AMI ID** | \`${{ env.AMI_ID }}\` |"
            echo "| **Region** | ${{ vars.AWS_REGION }} |"
            echo "| **Subnet** | ${{ vars.SUBNET_ID }} |"
            echo "| **Security Group** | ${{ vars.SECURITY_GROUP_ID }} |"
            echo "| **Commit** | ${{ github.sha }} |"
            echo ""
            echo "### Quick Launch Command"
            echo "\`\`\`bash"
            echo "aws ec2 run-instances \\"
            echo "  --image-id ${{ env.AMI_ID }} \\"
            echo "  --instance-type t2.micro \\"
            echo "  --key-name YOUR_KEY_NAME \\"
            echo "  --security-group-ids ${{ vars.SECURITY_GROUP_ID }} \\"
            echo "  --subnet-id ${{ vars.SUBNET_ID }} \\"
            echo "  --region ${{ vars.AWS_REGION }} \\"
            echo "  --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=csye6225-app}]'"
            echo "\`\`\`"
          } >> $GITHUB_STEP_SUMMARY